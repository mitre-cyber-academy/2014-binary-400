Name: Reverse engineering

Description: User will be given an object file (that is stripped) named "keyArchive". This program will begin by prompting the user for a password. However, it is literally impossible to get the password. The user must patch the assembly in order to proceed. The program will then continue checking for 2 files that do not exist on the user's machine (and at all for that matter). The user can try to create these 2 files or patch the program. Once done the program will go into a function that produces a fake key. The program contains a function that is unreachable. The user must patch the assembly to make it jump to this function. They can see this function if they use a proper debugger/disassembler, gdb and the like will not be able to disassemble the program. Also, the user cannot just jump directly to this function. The unreachable function will only run if a global boolean value is set to 1. Because of this, the user must patch it in 2 places. First, they must jump to where the boolean value is set to one and then to the unreachable function. 

Solution: In order to solve this, I used the freeware version of Hex Ray's IDA. Only the windows version of this is available. In order to run the IDA freeware on Linux, install Wine. Once IDA is installed, make sure you edit the guiconfig, located at `~/.wine/drive_c/Program Files/IDA Free/cfg`. Once you open this make DISPLAY_PATCH_SUBMENU = YES. Once this is done, you can patch assembly in IDA. Now open IDA and select the object file to be patched. After the program is done analyzing the disassembly, it will go to a graph view. When you get to this screen, hit spacebar until you get a disassembly view. Now since our object file is stripped, you won't be able to see the names of functions. However, you can see where the program starts thanks to the strings feature of IDA (Note: The string used for SHA1 hash for the key is altered by a separate function, so the user can't just SHA1 the string). Now you can start analyzing the program flow. First you must find the address where the global value is set to 1. After this you must find where the unreachable function is. Once you find the function that produces the fake key, you will see the unreachable function immediately after it (at least, this is what happened on my machine). Once you find the start address of the unreachable function, right click the address and select name function and name it whatever you wish. Now go back to the main function. Once here, you need to patch the assembly twice. First, where the boolean is set to 1 and then immediately after to the unreachable function. To do this, click the desired address you want to patch. Once done, in the edit menu, select the patch program option and then select Assemble...  now it will prompt you for the x86 function and operand(s). Here all you need to do is type "jmp <name_of_unreachable_func>". Hit okay and then another thing will pop up. Hit cancel. Now File->Produce File->Create DIF File. Name the dif file whatever you like. From here you need to patch the program. There are many ways to do this, but I used a python script from http://stalkr.net/files/ida/idadif.py (This file is src/ on the repo). Now in console, do python idadif.py keyArchive <name>.dif. Once complete, run the object file and it will produce the key.

To compile: gcc -Wall -m32 reverseme.c -o keyArchive -lssl -lcrypto
To strip: strip -s keyArchive 